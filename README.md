### *前端VUE  +  后端springCloud微服务分布式集群*
### *BtoC：电商客户前台+管理后台*
---
### 一、环境搭建

1. 配置linux和docker--mysql、redis

2. 在github上新建仓库，设置ignore文件

3. clone仓库到本地，用idea打开

4. 在idea上配置ignore文件设置，搭建聚合maven工程框架

5. 创建各模块数据库，导入数据库文件

   至此，基本运行环境已经配置完毕
--- 
### 二、引入后台管理系统

1. 直接在主工程里导入[人人开源](https://gitee.com/renrenio)的后台管理系统源码

2. 创建后台管理系统数据库

3. 在vscode里导入前端vue文件，install

4. 进行前后联调

5. 新建common功能模块，设置共有依赖、bean、配置文件等

6. 配置[人人开源](https://gitee.com/renrenio)的逆向工程生成器逆向代码，配置mybatis+和数据源，测试基础crud
---
### 三、分布式组件配置 

#### *使用spring-cloud-alibaba系列组件进行分布式配置*

以下1和2配置的使用步骤均已通过【gulimall-coupon模块的CouponController类】和【gulimall-coupon模块的MemberController类】进行了注解说明，可查看[官方文档](https://github.com/alibaba/spring-cloud-alibaba)进行完整配置

1. 使用Nacos：作为注册中心和配置中心----给每一个功能模块以及Nacos服务页进行配置

2. 配置feign：远程转发某台服务器的请求到已经注册过的其他服务器上

3. 使用gateway：提供路由服务，支持断言，底层是netty
---
### 四、商品管理——分类管理

#### *本小节功能重在对前端vue的修改完善，后端逻辑比较简单*

各部分业务均采用后端-前端-后端.....的顺序进行编写调试

如部分前端或者前后端交互的问题无法解决，选择直接使用**postman**进行测试，无伤大雅

以下是注意点：

1. 前后端交互（网关转发等）的路由配置，浏览器跨域问题
    - 暂时不想深究了....bug一大堆......头风发作中.....

2. 增删改查业务的设计
    - 逻辑删除：按数字进行状态映射配置，调用逆向工程的删除方法即可

3. 版本依赖做不好，bug改到老
---
### 五、商品服务--品牌管理

1. 使用renrenfast逆向生成的基础vue文件就可以完成简单的表格式增删改查界面和功能

2. 选择使用阿里云的对象存储服务，设置服务端签名，前端先发送请求获取服务端签名，然后给阿里云提交请求，就可以直接把上传的数据直传到阿里云云存储空间

3. 采用网关路由转换地址

4. 后端对前端传过来的数据进行不同类型的校验（空检验，格式校验；单校验，分组校验，自定义校验
---
### 六、商品服务--属性分页|平台属性 等等

#### *本节重点主要在于对常规增删改查操作的细节把控*

1. 属性分页：点击树状图节点，分页展示当前节点信息
    - 弄清传递的路径参数
    - 从需求出发，在controller层接收参数重新构建处理方法，然后从service层接口开始，在实现层中具体实现该方法
    - 对多表操作解耦合，对涉及联表查询的操作，统一设计在service层完成对联表关系字段的填充

2. 平台属性
    - 全面调整对entity层的注解使用，规范为使用“vo”对象来统一接收请求和封装对象
---
### 七、仓储服务

#### *继续增删改查*
---
### 八、Elaticsearch分布式全局搜索引擎

[elastic官网](https://www.elastic.co/cn/elasticsearch/)

[elastic原理介绍](https://www.cnblogs.com/dreamroute/p/8484457.html)

1. 我们选择采用搜索效率更高的   Elaticsearch引擎+kibana图形客户端   进行全局搜索相关的数据存储及分词快速搜索工作

2. 通过java客户端来操作此数据库

3. 建立相关索引，把仅需要展现的数据和需要展现+检索的数据分类存储到数据库中，可节约搜索时内存性能的大量消耗
---
### 九、商城业务

1. 客户前端首页三级分类数据查询显示：设立vo类，通过feign远程调用不同微服务完成查询

2. 搭建域名访问环境：
**需求**：客户不能通过访问localhost+端口号去进入结果页，而是访问指定路径。如http://localhost:10000---------http://gulimall.com
**解决**：通过nginx+网关路由去做负载均衡转发请求
* 在本机建立域名映射，保证能通过新域名访问到原始域名
* 在nginx设置该映射，保证能通过linux地址（新地址）访问到新域名
* 在nginx设置网关映射，保证能通过网关地址访问到新域名
* 在网关设置路由，保证能通过路由地址（新地址）访问到新域名
* 为什么要请求要经过网关？保证即使改变了原有端口号，nginx配置的端口号也不用动态改变，而是由网关从注册中心去寻找服务，随后进行负载均衡
---
### 十、性能测试

#### *本节主要对微服务板块和中间件进行简单压力测试和性能监控，根据反馈数据来优化服务*

1. 测试内容
* 微服务板块的吞吐量和响应时间
* 中间件的吞吐量和响应时间
* 全链路的吞吐量和响应时间
2. 测试方式
* 利用JMeter进行性能压力测试
* 利用jvisualvm进行java线程性能监控
3. 优化
* 再进行性能测试后，得到结果：加载静态资源花费时间过多  多级分类查询业务效率低
* 优化方式是进行nginx动静分离，把静态资源布置在nginx上。如下图

![image](https://user-images.githubusercontent.com/100891076/178511782-fb7fb30a-fb46-446b-940e-9af844b30aac.png)

---
### 十一、Redis缓存和锁
#### 1.为什么要用缓存层？
通过上一节的性能测试，我们发现最影响响应速度的就是在数据库中查询分类数据这一活动，对于这个操作，我们并不想去改变该查询本身的业务逻辑，但是该查询每次都是查询并返回所有数据，我们完全可以把数据封装在缓存层，每次去调用缓存层的数据，就可以极大优化查询时间。
#### 2.由此，我们对缓存层的使用进化如下：
1. 使用普通的本地缓存——没法解决缓存雪崩、缓存穿透、缓存击穿等问题
2. 使用synchronized锁——多个微服务就会有多个锁，也就是有多个线程进入项目，并不满足只有单线程的要求，所有我们需要分布式锁  并且  在部署多个微服务时，使用本地缓存会出现缓存数据不一致的情况
3. 使用普通的redis分布式缓存——在分布式环境下，只适用单服务的高性能锁无法使用，如goc包下的默认
4. 使用Redisson（是分布式下各种高性能锁的集合），但是依旧可能会有时间差下的数据库与缓存暂时数据不一致问题，解决方法有：
   * 把经常要写的数据直接不经过缓存到数据库处理
   * 放弃治疗，容忍暂时的数据不一致
   * 加完全的单线程锁——缺点是系统太笨重
   * 对并发几率比较小的数据，每隔一段时间触发读的主动更新，也可以防止一定的脏数据
   * 防止脏数据比较直接的方式就是加读写锁（读写锁在读多写少的情况的业务情况下，对效率几乎没有影响）
   * 使用中间件Canal同步更新缓存（通过记录数据库日志实现）（Canal其他使用场景是通过分析访问记录表和商品信息表得到异构系统用户推荐表，把用户感兴趣的商品推到用户首页）
#### 3.我们在本项目中使用的解决措施是：
* 设置缓存的所有数据都有过期时间
* 在数据库进行写操作后直接删除原有缓存（失效模式）
* 配置读写锁   
但是还是可能有暂时数据不一致的问题，我们决定容忍这些问题，不对系统进行过于纷繁的设计，简就是繁
#### 4. 最后，使用SpringCache整合缓存
在确定了如何处理缓存后，如果系统中有多处需要使用缓存的地方，我们总不能每个地方都像这样写一遍读逻辑，再写一遍写逻辑，太复杂了，所有我们选择使用SpringCache搭配Redis去整合缓存。
SpringCache本身的能力如何？总结：读多写少的常规操作，适合用这种缓存技术，特殊数据得特殊处理。理由如下：
1. 读模式：
缓存穿透：有针对空数据的自定义缓存设置
缓存击穿：读模式（查询）的时候系统有结合redis看是否要加锁；写模式是无锁设计的，要根据业务情况去自行设计
缓存穿透：有加缓存失效时间的自定义设置
2. 写模式
读写加锁
引入Canal
读多写少，直接取数据库查询就行




*--------------------更新中-------------------------*
